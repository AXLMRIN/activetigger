import axios from 'axios';
import { saveAs } from 'file-saver';
import { toPairs, values } from 'lodash';
import createClient, { Middleware } from 'openapi-fetch';
import { useCallback, useState } from 'react';

import streamSaver from 'streamsaver';
import type { paths } from '../generated/openapi';
import {
  AnnotationModel,
  AnnotationsDataModel,
  AvailableProjectsModel,
  ComputeBertopicModel,
  EvalSetDataModel,
  GenModel,
  LoginParams,
  ProjectBaseModel,
  ProjectStateModel,
  ProjectUpdateModel,
  ProjectionParametersModel,
  SimpleModelModel,
  SupportedAPI,
  TextDatasetModel,
  newBertModel,
} from '../types';
import { HttpError } from './HTTPError';
import { getAuthHeaders, useAuth } from './auth';
import config from './config';
import { useNotifications } from './notifications';
import { getAsyncMemoData, useAsyncMemo } from './useAsyncMemo';

/**
 * API methods
 */

// Add a timeout to the default fetch
async function fetchWithTimeout(input: Request) {
  const timeout = 120000;

  const controller = new AbortController();
  const timer = setTimeout(() => controller.abort(), timeout);
  try {
    const response = await fetch(input, {
      signal: controller.signal,
    });
    return response;
  } catch (error) {
    // on abort, it's a Timeout, generate an according Response
    if ((error as Error).name === 'AbortError')
      return new Response(JSON.stringify({ error: 'API timeout' }), {
        status: 408,
        headers: { 'Content-Type': 'application/json' },
      });
    // in case an other error occurres send it upstream
    return new Response(JSON.stringify({ error: 'API unreachable!' }), {
      status: 404,
      headers: { 'Content-Type': 'application/json' },
    });
  } finally {
    // in any case clear timeout
    clearTimeout(timer);
  }
}

// all API calls are handled by a client generated by the openapi-fetch library
// It uses the `paths` types generated from the API openApi specifications by running `npm run generate`
export const api = createClient<paths>({ baseUrl: `${config.api.url}`, fetch: fetchWithTimeout });
export const api_withouttimeout = createClient<paths>({
  baseUrl: `${config.api.url}`,
});

// This authMiddleware injects the auth headers for each API call
const authMiddleware: Middleware = {
  // on each request the middleware inject auth headers
  onRequest: ({ request }) => {
    const authenticatedUserJSON = localStorage.getItem('activeTigger.auth');
    const authenticatedUser = authenticatedUserJSON ? JSON.parse(authenticatedUserJSON) : null;
    if (authenticatedUser) {
      const authHeaders = getAuthHeaders(authenticatedUser);
      if (authHeaders) {
        toPairs(authHeaders.headers).map(([header, value]) => {
          if (request.headers.get(header) === null) request.headers.set(header, value);
        });
        //params.header = { ...params.header, username: authenticatedUser.username };
      }
      return request;
    }
    return undefined;
  },
};

api.use(authMiddleware);
api_withouttimeout.use(authMiddleware);

/**
 * Authentication methods
 * login and me are standard async functions and not hooks.
 * Because they are used directly by the auth centralized mechanism which is itself a hook/context.
 */

/**
 * login : POST a login form data to get an auth token
 * @param params LoginParams
 * @returns an access_token
 */
export async function login(params: LoginParams) {
  const res = await api.POST('/token', {
    headers: { 'Content-Type': 'application/x-www-form-urlencoded' },
    body: params,
    bodySerializer: (body) => new URLSearchParams(body as Record<string, string>),
  });

  if (res.data && !res.error) return res.data;
  else {
    throw new HttpError(
      res.response.status,
      // TODO: debug API type for error, data received are not coherent with types
      res.error.detail + '',
    );
  }
}

/**
 * logout : POST a login form data to get an auth token
 * @param params LoginParams
 * @returns an access_token
 */
export async function logout(token: string) {
  const res = await api.POST('/users/disconnect', {
    headers: {
      Authorization: `Bearer ${token}`,
    },
  });

  if (res.response.status === 200) return true;
  else {
    throw new HttpError(
      res.response.status,
      // TODO: debug API type for error, data received are not coherent with types
      'could not logout',
    );
  }
}

/**
 * me : GET an authenticated user info
 * @param token
 * @returns user
 */
export async function me(token: string) {
  const res = await api.GET('/users/me', {
    headers: {
      Authorization: `Bearer ${token}`,
    },
  });

  if (res.data) return res.data;
  else throw new HttpError(res.response.status, '');
}

/**
 * HOOKS
 * We use hooks functions for API calls to be able to use the useAuth hook inside of it.
 * It allows us also to use an internal state (handled by useAsyncMemo) for getters which simplifies the component code.
 */

/**
 * useUserProjects
 * retrieve authenticated user's projects list
 * @returns AvailableProjectsModel[] | undefined
 */
export function useUserProjects() {
  const { notify } = useNotifications();
  const [fetchTrigger, setFetchTrigger] = useState<boolean>(false);

  // This method is a GET it retrieves data by querying the API
  // but a hook can not be async it has to be a pure function
  // to handle the query API effect we use useAsyncMemo
  // useAsyncMemo generalizes the internal state management for us
  // useAsyncMemo internally has a generic useState and a useEffect
  // we use useAsyncMemo to lighten our API methods and our component code by providing a ready to consume state
  const projects = useAsyncMemo(async () => {
    // api calls uses openapi fetch that make sure that method GET, paths `/projects` and params respect API specs
    const res = await api.GET('/projects');
    if (res.data && !res.error)
      // TODO: type API response in Python code and remove the as unknown as AvailableProjectsModel[]
      return values(res.data.projects) as unknown as AvailableProjectsModel[];
    else {
      notify({ type: 'error', message: JSON.stringify(res.error) });
      throw new HttpError(res.response.status, '');
    }
  }, [fetchTrigger]);
  const reFetch = useCallback(() => setFetchTrigger((f) => !f), []);

  // here we use the getAsyncMemoData to return only the data or undefined and not the internal status
  return { projects: getAsyncMemoData(projects), reFetchProjects: reFetch };
}

export async function fetchUserProjects(): Promise<AvailableProjectsModel[]> {
  const res = await api.GET('/projects');
  if (res.data && !res.error) {
    return values(res.data.projects) as unknown as AvailableProjectsModel[];
  } else {
    throw new Error(JSON.stringify(res.error));
  }
}

/**
 * useCreateProject
 * provide a method to POST a new project
 * @returns void
 */
export function useCreateProject() {
  const { notify } = useNotifications();

  // POST method hook generates an async function which will do the API call
  // the component using this hook will decide when to use this method  in its lifecycle
  // (typically in a form submit handler)
  // useCallback is a react util which memoizes a function
  // the createProject function will change each time the authenticated user changes
  // therefore the component using this hook will not have to bother handling authentication it's done automatically here
  const createProject = useCallback(
    // this async function needs a ProjectDataModel payload as params
    async (project: ProjectBaseModel) => {
      // do the new projects POST call
      const res = await api_withouttimeout.POST('/projects/new', {
        // POST has a body
        body: project,
      });
      if (!res.error) {
        notify({ type: 'success', message: 'Project created' });
        return res['data'];
      } else
        throw new Error(
          Array.isArray(res.error.detail)
            ? res.error.detail.map((d) => d.msg).join('; ')
            : res.error.detail || res.error.toString(),
        );
    },
    [notify],
  );
  // this POST hook returns a function ready to be used by a component
  return createProject;
}

/**
 * Create test set
 */
export function useCreateValidSet() {
  const { notify } = useNotifications();
  const createTestSet = useCallback(
    async (projectSlug: string, dataset: string, testset: EvalSetDataModel) => {
      const res = await api.POST('/projects/evalset/add', {
        params: {
          query: { project_slug: projectSlug, dataset: dataset },
        },
        body: testset,
      });
      if (!res.error) notify({ type: 'success', message: 'Test data set uploaded' });
    },
    [notify],
  );
  return createTestSet;
}

/**
 * Drop valid set
 */
export function useDropEvalSet(projectSlug: string | null) {
  const { notify } = useNotifications();
  const dropTestSet = useCallback(
    async (dataset: string) => {
      if (!projectSlug) return;
      // do the new projects POST call
      const res = await api.POST('/projects/evalset/delete', {
        // POST has a body
        params: {
          query: { project_slug: projectSlug, dataset: dataset },
        },
      });
      if (!res.error) notify({ type: 'success', message: `Data set ${dataset} dropped` });
    },
    [notify, projectSlug],
  );
  return dropTestSet;
}

/**
 * Import dataset to predict
 */
export function usePredictOnDataset() {
  const { notify } = useNotifications();
  const predictOnDataset = useCallback(
    async (projectSlug: string, scheme: string, model_name: string, data: TextDatasetModel) => {
      // do the new projects POST call
      const res = await api.POST('/models/bert/predict', {
        // POST has a body
        params: {
          query: {
            project_slug: projectSlug,
            model_name: model_name,
            dataset: 'external',
            scheme: scheme,
          },
        },
        body: data,
      });
      if (!res.error) notify({ type: 'success', message: 'Start predicting on dataset' });
      else
        throw new Error(
          res.error.detail ? res.error.detail?.map((d) => d.msg).join('; ') : res.error.toString(),
        );
    },
    [notify],
  );
  return predictOnDataset;
}

/**
 * useDeleteProject
 * provide a method to delete existing projext
 * @returns void
 */
export function useDeleteProject() {
  const { notify } = useNotifications();
  const deleteProject = useCallback(
    async (projectSlug: string) => {
      // do the new projects POST call
      const res = await api.POST('/projects/delete', {
        params: {
          query: { project_slug: projectSlug },
        },
      });
      if (!res.error) notify({ type: 'success', message: 'Project deleted' });
    },
    [notify],
  );

  return deleteProject;
}

/**
 * useStatistics
 * GET the current stats of the project
 * @param projectSlug
 * @param currentScheme
 */
export function useStatistics(projectSlug: string | null, currentScheme: string | null) {
  const [fetchTrigger, setFetchTrigger] = useState<boolean>(false);

  const getStatistics = useAsyncMemo(async () => {
    if (projectSlug && currentScheme && currentScheme !== 'none' && currentScheme !== '') {
      const res = await api.GET('/projects/{project_slug}/statistics', {
        params: {
          path: { project_slug: projectSlug },
          query: { scheme: currentScheme },
        },
      });

      //return res.data.params;
      return res.data;
    }
    //TODO: notify
    return null;
    // in this dependencies list we add projectSlug has a different API call will be made if it changes
    // we also add the fetchTrigger state in the dependencies list to make sur that any change to this boolean triggers a new API call
  }, [projectSlug, currentScheme, fetchTrigger]);

  const reFetch = useCallback(() => setFetchTrigger((f) => !f), []);

  return { statistics: getAsyncMemoData(getStatistics), reFetchStatistics: reFetch };
}

/**
 * useProject
 * GET project by projectSlug
 * @param projectSlug
 * @returns ProjectModel
 */
export function useProject(projectSlug?: string) {
  // it's a GET data hook. It's using the exact same pattern as useUserProjects but we has a reFetch method
  // reFetch method should trigger a new API call to update the data from API

  // 1. auth is automatically managed by an API middleware see core/auth.tsx

  // 2. create a fetchTrigger, a simple boolean which we will use to trigger an API call
  const [fetchTrigger, setFetchTrigger] = useState<boolean>(false);
  const { notify } = useNotifications();

  // 3. use an internal state to store the project thanks to useAsyncMemo
  const project = useAsyncMemo(async () => {
    if (projectSlug) {
      const res = await api.GET('/projects/{project_slug}', {
        params: {
          path: { project_slug: projectSlug },
        },
      });
      if (res.error) {
        notify({ type: 'error', message: JSON.stringify(res.error) });
        return null;
      }
      //return res.data.params;
      return res.data;
    }
    return null;
    // in this dependencies list we add projectSlug has a different API call will be made if it changes
    // we also add the fetchTrigger state in the dependencies list to make sur that any change to this boolean triggers a new API call
  }, [projectSlug, fetchTrigger, notify]);

  // 4. make sure to simplify the data returned by discarding the status
  // we also return a refetch method which toggle the fetchTrigger state in order to trigger a new API call

  const reFetch = useCallback(() => setFetchTrigger((f) => !f), []);
  return { project: getAsyncMemoData(project), reFetch };
}

/**
 * delete a scheme
 (its a hook)
 */
export function useDeleteScheme(projectSlug: string, schemeName: string | null) {
  const { notify } = useNotifications();

  const deleteScheme = useCallback(async () => {
    if (schemeName) {
      // do the new projects POST call
      const res = await api.POST('/schemes/{action}', {
        params: {
          path: { action: 'delete' },
          query: { project_slug: projectSlug },
        },
        body: { project_slug: projectSlug, name: schemeName, kind: '', labels: [] },
      });
      if (!res.error) notify({ type: 'success', message: 'Scheme deleted' });
    }
  }, [projectSlug, schemeName, notify]);

  return deleteScheme;
}

/**
 * create a scheme
 * (its a hook)
 */
export function useAddScheme(projectSlug: string) {
  const { notify } = useNotifications();

  const addScheme = useCallback(
    async (schemeName: string, kind: string) => {
      if (schemeName) {
        // do the new projects POST call
        const res = await api.POST('/schemes/{action}', {
          params: {
            path: { action: 'add' },
            query: { project_slug: projectSlug },
          },
          body: { project_slug: projectSlug, name: schemeName, kind: kind, labels: [] },
        });
        if (!res.error) notify({ type: 'success', message: 'Scheme add' });

        return true;
      }
      return null;
    },
    [projectSlug, notify],
  );

  return addScheme;
}

/**
 * rename a scheme
 */
export function useRenameScheme(projectSlug: string, schemeName: string) {
  const { notify } = useNotifications();
  const renameScheme = useCallback(
    async (newSchemeName: string) => {
      if (schemeName && newSchemeName) {
        // do the new projects POST call
        const res = await api.POST('/schemes/rename', {
          params: {
            query: { project_slug: projectSlug, old_name: schemeName, new_name: newSchemeName },
          },
        });
        if (!res.error) notify({ type: 'success', message: 'Scheme renamed' });
        return true;
      }
      return null;
    },
    [projectSlug, notify, schemeName],
  );

  return renameScheme;
}

/**
 * duplicate a scheme
 */
export function useDuplicateScheme(projectSlug: string, schemeName: string) {
  const { notify } = useNotifications();
  const duplicateScheme = useCallback(async () => {
    if (schemeName) {
      // do the new projects POST call
      const res = await api.POST('/schemes/duplicate', {
        params: {
          query: { project_slug: projectSlug, scheme_name: schemeName },
        },
      });
      if (!res.error) notify({ type: 'success', message: 'Scheme duplicated' });
      return true;
    }
    return null;
  }, [projectSlug, notify, schemeName]);

  return duplicateScheme;
}

/**
 * create a feature
 **/
export function useAddFeature() {
  const { notify } = useNotifications();

  const addFeature = useCallback(
    async (
      projectSlug: string | null,
      featureType: string,
      featureName: string,
      featureParameters: Record<string, string | number | undefined> | null,
    ) => {
      if (!featureName) featureName = featureType;

      if (featureType && featureParameters && projectSlug) {
        const res = await api.POST('/features/add', {
          params: {
            query: { project_slug: projectSlug },
          },
          body: { name: featureName, type: featureType, parameters: featureParameters },
        });
        if (!res.error) notify({ type: 'warning', message: 'Features are computing' });
        return true;
      }
      return false;
    },
    [notify],
  );

  return addFeature;
}

/**
 * delete a feature
 * @param projectSlug
 * @returns deleteFeature
 *  */
export function useDeleteFeature(projectSlug: string | null) {
  const { notify } = useNotifications();

  const deleteFeature = useCallback(
    async (featureName: string | null) => {
      if (featureName && projectSlug) {
        const res = await api.POST('/features/delete', {
          params: {
            query: { project_slug: projectSlug, name: featureName },
          },
        });
        if (!res.error) notify({ type: 'success', message: 'Features deleted' });
        return true;
      }
      return false;
    },
    [projectSlug, notify],
  );

  return deleteFeature;
}

/**
 * Get feature infro
 */
export function useGetFeatureInfo(project_slug: string | null, project: unknown) {
  const getFeatureInfo = useAsyncMemo(async () => {
    if (project_slug) {
      const res = await api.GET('/features/available', {
        params: {
          query: {
            project_slug: project_slug,
          },
        },
      });
      if (!res.error && res.data) {
        return res.data;
      }
    }
    return null;
  }, [project_slug, project]);

  return { featuresInfo: getAsyncMemoData(getFeatureInfo) };
}

/**
 * Get the id of the next element
 * with a specific configuration of selection
 *
 * @param projectSlug
 * @param currentScheme
 * @param selectionConfig
 * @returns ElementId
 */
export function useGetNextElementId(
  projectSlug: string | null,
  currentScheme: string | null,
  selectionConfig: {
    mode: string;
    sample: string;
    label?: string;
    label_maxprob?: string;
    filter?: string;
    frameSelection?: boolean;
    frame?: number[];
    user?: string;
  },
  history: string[],
  phase: string,
) {
  const { notify } = useNotifications();
  const getNextElementId = useCallback(async () => {
    if (projectSlug && currentScheme) {
      const res = await api.POST('/elements/next', {
        params: { query: { project_slug: projectSlug } },
        body: {
          scheme: currentScheme,
          selection: selectionConfig.mode,
          sample: selectionConfig.sample,
          label: selectionConfig.label,
          filter: selectionConfig.filter,
          history: history,
          frame: selectionConfig.frameSelection ? selectionConfig.frame : null, // only if frame option selected
          dataset: phase,
          label_maxprob: selectionConfig.label_maxprob,
          user: selectionConfig.user,
        },
      });
      if (res.data?.element_id)
        return { element_id: res.data?.element_id, n_sample: res.data?.n_sample };
      else return null;
    } else {
      notify({ type: 'error', message: 'Select a project/scheme to get elements' });
      return null;
    }
  }, [projectSlug, currentScheme, notify, history, selectionConfig, phase]);

  return { getNextElementId };
}

/**
 * Get element content by specific id
 */
export function useGetElementById(projectSlug: string | null, currentScheme: string | null) {
  const getElementById = useCallback(
    async (elementId: string, dataset: string) => {
      if (projectSlug) {
        const res = await api.GET('/elements/{element_id}', {
          params: {
            path: { element_id: elementId },
            query: { project_slug: projectSlug, scheme: currentScheme, dataset: dataset },
          },
        });
        if (res.response.status === 200) return res.data;
        else return null;
      }
      return null;
    },
    [projectSlug, currentScheme],
  );

  return { getElementById };
}

/**
 * add an annotation
 */
export function useAddAnnotation(
  projectSlug: string | null,
  scheme: string | null,
  dataset: string,
) {
  const addAnnotation = useCallback(
    async (
      element_id: string,
      label: string | null,
      comment: string | null,
      selection: string | null,
    ) => {
      // do the new projects POST call
      if (projectSlug && scheme) {
        await api.POST('/annotation/{action}', {
          params: {
            path: { action: 'add' },
            query: { project_slug: projectSlug },
          },
          body: {
            project_slug: projectSlug,
            element_id: element_id,
            label: label,
            scheme: scheme,
            dataset: dataset,
            comment: comment,
            selection: selection,
          },
        });

        return true;
      }
      return false;
    },
    [projectSlug, scheme, dataset],
  );

  return { addAnnotation };
}

/**
 * add a table of annotations
 */
export function useAddTableAnnotations(
  projectSlug: string | null,
  scheme: string | null,
  dataset: string | null,
) {
  const { notify } = useNotifications();

  const addTableAnnotations = useCallback(
    async (table: AnnotationModel[]) => {
      if (projectSlug && scheme) {
        const res = await api.POST('/annotation/table', {
          params: {
            query: { project_slug: projectSlug },
          },
          body: {
            annotations: table,
            dataset: dataset ? dataset : 'train',
          },
        });
        if (!res.error) notify({ type: 'success', message: 'Annotations added' });

        return true;
      }
      return false;
    },
    [projectSlug, scheme, notify, dataset],
  );

  return { addTableAnnotations };
}

/**
 * create a new label
 */
export function useAddLabel(projectSlug: string | null, scheme: string | null) {
  const { notify } = useNotifications();

  const addLabel = useCallback(
    async (label: string) => {
      if (projectSlug && scheme) {
        const res = await api.POST('/schemes/label/{action}', {
          params: {
            path: { action: 'add' },
            query: { project_slug: projectSlug, scheme: scheme, label: label },
          },
        });
        if (!res.error) notify({ type: 'success', message: 'New label created' });

        return true;
      }
      return false;
    },
    [projectSlug, scheme, notify],
  );

  return { addLabel };
}

/**
 * Delete a label
 */
export function useDeleteLabel(projectSlug: string | null, scheme: string | null) {
  const { notify } = useNotifications();

  const deleteLabel = useCallback(
    async (label: string) => {
      if (projectSlug && scheme) {
        const res = await api.POST('/schemes/label/{action}', {
          params: {
            path: { action: 'delete' },
            query: { project_slug: projectSlug, scheme: scheme, label: label },
          },
        });
        if (!res.error) notify({ type: 'success', message: 'Label deleted' });

        return true;
      }
      return false;
    },
    [projectSlug, scheme, notify],
  );

  return { deleteLabel };
}

/**
 * Rename a label
 */
export function useRenameLabel(projectSlug: string | null, scheme: string | null) {
  const { notify } = useNotifications();

  const renameLabel = useCallback(
    async (formerLabel: string, newLabel: string) => {
      if (projectSlug && scheme) {
        const res = await api.POST('/schemes/label/rename', {
          params: {
            query: {
              project_slug: projectSlug,
              scheme: scheme,
              former_label: formerLabel,
              new_label: newLabel,
            },
          },
        });
        if (!res.error) notify({ type: 'success', message: 'Label renamed' });
        else notify({ type: 'error', message: 'Error when renamed' });
      }

      return true;
    },
    [projectSlug, scheme, notify],
  );

  return { renameLabel };
}

export function useUpdateSimpleModel(projectSlug: string | null, scheme: string | null) {
  const { notify } = useNotifications();

  const updateSimpleModel = useCallback(
    async (formData: SimpleModelModel) => {
      if (projectSlug && formData.features && scheme && formData.model && formData.params) {
        const res = await api.POST('/models/simplemodel', {
          params: {
            query: {
              project_slug: projectSlug,
            },
          },
          body: {
            features: formData.features,
            scheme: scheme,
            model: formData.model,
            params: formData.params,
            standardize: false,
            dichotomize: formData.dichotomize,
            cv10: formData.cv10,
          },
        });

        if (!res.error) notify({ type: 'warning', message: 'Training model' });
      }
      return true;
    },
    [projectSlug, scheme, notify],
  );

  return { updateSimpleModel };
}

/**
 * Get trained simplemodel for a user/scheme
 */
export function useGetSimpleModel(
  project_slug: string | null,
  scheme: string | null,
  project: unknown,
) {
  const [fetchTrigger, setFetchTrigger] = useState<boolean>(false);

  const getSimpleModel = useAsyncMemo(async () => {
    if (scheme && project_slug) {
      const res = await api.GET('/models/simplemodel', {
        params: {
          query: {
            project_slug: project_slug,
            scheme: scheme,
          },
        },
      });
      if (!res.error && res.data) {
        return res.data;
      }
    }
    return null;
  }, [project_slug, scheme, fetchTrigger, project]);

  const reFetch = useCallback(() => setFetchTrigger((f) => !f), []);

  return { currentModel: getAsyncMemoData(getSimpleModel), reFetchSimpleModel: reFetch };
}

/**
 * Get users for a project
 */
export function useUsersAuth(projectSlug: string | null) {
  const [fetchTrigger, setFetchTrigger] = useState<boolean>(false);

  const { notify } = useNotifications();
  const getProjectUsers = useAsyncMemo(async () => {
    if (projectSlug) {
      const res = await api.GET('/projects/auth', {
        params: { query: { project_slug: projectSlug } },
      });
      if (!res.error) return res.data.auth;
    }
    return null;
  }, [notify, projectSlug, fetchTrigger]);

  const reFetch = useCallback(() => setFetchTrigger((f) => !f), []);

  return { authUsers: getAsyncMemoData(getProjectUsers), reFetchUsersAuth: reFetch };
}

/**
 * Delete a user auth
 */
export function useDeleteUserAuthProject(projectSlug: string | null, reFetchUsersAuth: () => void) {
  const { notify } = useNotifications();
  const deleteUserAuth = useCallback(
    async (username: string | null) => {
      if (projectSlug && username) {
        const res = await api.POST('/users/auth/{action}', {
          params: {
            path: { action: 'delete' },
            query: { project_slug: projectSlug, username: username },
          },
        });
        if (!res.error) notify({ type: 'success', message: 'Auth deleted for user' });
        reFetchUsersAuth();
        return true;
      }
      return null;
    },
    [projectSlug, notify, reFetchUsersAuth],
  );

  return { deleteUserAuth };
}

/**
 * Get all users
 */
export function useUsers() {
  const [fetchTrigger, setFetchTrigger] = useState<boolean>(false);

  const users = useAsyncMemo(async () => {
    const res = await api.GET('/users', {});
    if (!res.error) return res.data;
    return null;
  }, [fetchTrigger]);

  const reFetch = useCallback(() => setFetchTrigger((f) => !f), []);

  return { users: getAsyncMemoData(users), reFetchUsers: reFetch };
}

/**
 * Create a user
 */
export function useCreateUser(reFetchUsers: () => void) {
  // TODO :  check the strengh of the password
  const { notify } = useNotifications();

  const createUser = useCallback(
    async (username: string, password: string, status: string, mail: string) => {
      const res = await api.POST('/users/create', {
        params: {
          query: {
            username_to_create: username,
            password: password,
            status: status,
            mail: mail,
            dummy: true,
          },
        },
      });
      if (!res.error) notify({ type: 'success', message: 'User created' });
      reFetchUsers();
      return true;
    },
    [notify, reFetchUsers],
  );

  return { createUser };
}

/**
 * Delete a user
 */
export function useDeleteUser(reFetchUsers: () => void) {
  const { notify } = useNotifications();

  const deleteUser = useCallback(
    async (username: string | null) => {
      if (username) {
        const res = await api.POST('/users/delete', {
          params: {
            query: { user_to_delete: username },
          },
        });
        if (!res.error) notify({ type: 'success', message: 'User deleted' });
        reFetchUsers();
        return true;
      }
      return null;
    },
    [notify, reFetchUsers],
  );

  return { deleteUser };
}

/**
 * Create user auth
 */
export function useAddUserAuthProject(projectSlug: string | null, reFetchUsersAuth: () => void) {
  const { notify } = useNotifications();
  const addUserAuth = useCallback(
    async (username: string, auth: string) => {
      if (projectSlug && username) {
        const res = await api.POST('/users/auth/{action}', {
          params: {
            path: { action: 'add' },
            query: { project_slug: projectSlug, username: username, status: auth },
          },
        });
        if (!res.error) notify({ type: 'success', message: 'Auth deleted for user' });
        reFetchUsersAuth();
        return true;
      }
      return null;
    },
    [projectSlug, notify, reFetchUsersAuth],
  );

  return { addUserAuth };
}

/**
 * Train a new bert project
 */
export function useTrainBertModel(projectSlug: string | null, scheme: string | null) {
  const { notify } = useNotifications();
  const trainBertModel = useCallback(
    async (dataForm: newBertModel) => {
      if (projectSlug && scheme && dataForm) {
        const res = await api.POST('/models/bert/train', {
          params: {
            query: { project_slug: projectSlug },
          },
          body: {
            project_slug: projectSlug,
            scheme: scheme,
            base_model: dataForm.base,
            name: dataForm.name || '',
            test_size: dataForm.test_size || 0.2,
            params: dataForm.parameters,
            dichotomize: dataForm.dichotomize,
            class_balance: dataForm.class_balance || false,
            loss: dataForm.loss || 'cross_entropy',
            class_min_freq: dataForm.class_min_freq || 1,
            exclude_labels: dataForm.exclude_labels || [],
          },
        });
        if (!res.error) notify({ type: 'warning', message: 'Bertmodel training' });
        return true;
      }
      return null;
    },
    [projectSlug, notify, scheme],
  );

  return { trainBertModel };
}

/**
 * Stop training process for the user
 */
export function useStopTrainBertModel(projectSlug: string | null) {
  const { notify } = useNotifications();
  const stopTraining = useCallback(async () => {
    if (projectSlug) {
      const res = await api.POST('/models/bert/stop', {
        params: {
          query: {
            project_slug: projectSlug,
          },
        },
      });
      if (!res.error) notify({ type: 'success', message: 'Training stopped' });
      return true;
    }
    return null;
  }, [projectSlug, notify]);

  return { stopTraining };
}

/**
 * Rename bert model
 */
export function useRenameBertModel(projectSlug: string | null) {
  const { notify } = useNotifications();
  const renameBertModel = useCallback(
    async (former_model_name: string, new_model_name: string) => {
      if (projectSlug) {
        const res = await api.POST('/models/bert/rename', {
          params: {
            query: {
              project_slug: projectSlug,
              former_name: former_model_name,
              new_name: new_model_name,
            },
          },
        });
        if (!res.error) notify({ type: 'success', message: 'Model renamed' });
        return true;
      }
      return null;
    },
    [projectSlug, notify],
  );

  return { renameBertModel };
}

/**
 * Delete bert model
 */
export function useDeleteBertModel(projectSlug: string | null) {
  const { notify } = useNotifications();
  const deleteBertModel = useCallback(
    async (model_name: string) => {
      if (projectSlug) {
        const res = await api.POST('/models/bert/delete', {
          params: {
            query: {
              project_slug: projectSlug,
              bert_name: model_name,
            },
          },
        });
        if (!res.error) notify({ type: 'success', message: 'Model deleted' });
        return true;
      }
      return null;
    },
    [projectSlug, notify],
  );

  return { deleteBertModel };
}

/**
 * Get model informations
 */
export function useModelInformations(
  project_slug: string | null,
  model_name: string | null,
  isComputing: boolean,
) {
  const [fetchTrigger, setFetchTrigger] = useState<boolean>(false);

  const modelInformations = useAsyncMemo(async () => {
    if (model_name && project_slug) {
      const res = await api.GET('/models/bert', {
        params: { query: { project_slug: project_slug, name: model_name } },
      });
      if (!res.error) return res.data;
    }
    return null;
  }, [fetchTrigger, model_name, isComputing]);

  const reFetch = useCallback(() => setFetchTrigger((f) => !f), []);

  return { model: getAsyncMemoData(modelInformations), reFetchModelInformation: reFetch };
}

/**
 * Compute model prediction
 */
export function useComputeModelPrediction(projectSlug: string | null, batchSize: number) {
  const { notify } = useNotifications();
  const computeModelPrediction = useCallback(
    async (model_name: string, dataset: string, scheme: string) => {
      if (projectSlug) {
        const res = await api.POST('/models/bert/predict', {
          params: {
            query: {
              project_slug: projectSlug,
              model_name: model_name,
              dataset: dataset,
              batch_size: batchSize,
              scheme: scheme,
            },
          },
        });
        if (!res.error)
          notify({ type: 'warning', message: 'Computing prediction. It can take some time.' });
        return true;
      }
      return null;
    },
    [projectSlug, notify, batchSize],
  );

  return { computeModelPrediction };
}

/**
 * Get file features
 */
export function useGetFeaturesFile(projectSlug: string | null) {
  const { notify } = useNotifications();
  const getFeaturesFile = useCallback(
    async (features: string[], format: string) => {
      if (projectSlug) {
        const res = await api.GET('/export/features', {
          params: {
            query: {
              project_slug: projectSlug,
              features: features,
              format: format,
            },
          },
          parseAs: 'blob',
        });

        if (!res.error) {
          notify({ type: 'success', message: 'Exporting the features of the model' });
          saveAs(res.data, `features_${features.join('-')}_${projectSlug}.${format}`);
        }
        return true;
      }
      return null;
    },
    [projectSlug, notify],
  );

  return { getFeaturesFile };
}

/**
 * Get file projection
 */
export function useGetProjectionFile(projectSlug: string | null) {
  const { notify } = useNotifications();
  const getProjectionFile = useCallback(
    async (format: string) => {
      if (projectSlug) {
        const res = await api.GET('/export/projection', {
          params: {
            query: {
              project_slug: projectSlug,
              format: format,
            },
          },
          parseAs: 'blob',
        });

        if (!res.error) {
          notify({ type: 'success', message: 'Exporting the vizualisation of the model' });
          saveAs(res.data, `projection_${projectSlug}.${format}`);
        }
        return true;
      }
      return null;
    },
    [projectSlug, notify],
  );

  return { getProjectionFile };
}

/**
 * Get file annotations
 */
export function useGetAnnotationsFile(projectSlug: string | null) {
  const { notify } = useNotifications();
  const getAnnotationsFile = useCallback(
    async (scheme: string, format: string, dataset: string) => {
      if (projectSlug) {
        const res = await api.GET('/export/data', {
          params: {
            query: {
              project_slug: projectSlug,
              scheme: scheme,
              format: format,
              dataset: dataset,
            },
          },
          parseAs: 'blob',
        });

        if (!res.error) {
          notify({ type: 'success', message: 'Exporting the annotated data' });
          saveAs(res.data, `annotations_${projectSlug}_${scheme}_${dataset}.${format}`);
        }
        return true;
      }
      return null;
    },
    [projectSlug, notify],
  );

  return { getAnnotationsFile };
}

/**
 * Get file predictions
 */
export function useGetPredictionsFile(projectSlug: string | null) {
  const { notify } = useNotifications();
  const getPredictionsFile = useCallback(
    async (model: string, format: string, dataset: string = 'all') => {
      if (projectSlug) {
        const res = await api.GET('/export/prediction', {
          params: {
            query: {
              project_slug: projectSlug,
              name: model,
              format: format,
              dataset: dataset,
            },
          },
          parseAs: 'blob',
        });

        if (!res.error) {
          notify({ type: 'success', message: 'Exporting the predictions data' });
          saveAs(res.data, `predictions_${projectSlug}_${model}_${dataset}.${format}`);
        }
        return true;
      }
      return null;
    },
    [projectSlug, notify],
  );

  return { getPredictionsFile };
}

/**
 * Get file predictions simplemodel
 */
export function useGetPredictionsSimplemodelFile(projectSlug: string | null) {
  const { notify } = useNotifications();
  const getPredictionsSimpleModelFile = useCallback(
    async (scheme: string, format: string) => {
      if (projectSlug) {
        const res = await api.GET('/export/prediction/simplemodel', {
          params: {
            query: {
              project_slug: projectSlug,
              scheme: scheme,
              format: format,
            },
          },
          parseAs: 'blob',
        });

        if (!res.error) {
          notify({ type: 'success', message: 'Exporting the predictions data' });
          saveAs(res.data, `predictions_${projectSlug}_${scheme}.${format}`);
        }
        return true;
      }
      return null;
    },
    [projectSlug, notify],
  );

  return { getPredictionsSimpleModelFile };
}

/**
 * Get file generations
 */
export function useGetGenerationsFile(projectSlug: string | null, filters: string[]) {
  const { notify } = useNotifications();
  const getGenerationsFile = useCallback(async () => {
    if (projectSlug) {
      const res = await api.POST('/export/generations', {
        params: {
          query: {
            project_slug: projectSlug,
          },
        },
        body: { filters: filters },
        parseAs: 'blob',
      });

      if (!res.error) {
        notify({ type: 'success', message: 'Exporting the generations data' });
        saveAs(res.data, 'generations.csv');
      }
      return true;
    }
    return null;
  }, [projectSlug, notify, filters]);

  return { getGenerationsFile };
}

/**
 * Drop elements for a user/project
 */
export function useDropGeneratedElements(projectSlug: string | null, username: string | null) {
  const { notify } = useNotifications();
  const dropGeneratedElements = useCallback(async () => {
    if (!projectSlug) return;
    // do the new projects POST call
    const res = await api.POST('/generate/elements/drop', {
      // POST has a body
      params: {
        query: { project_slug: projectSlug, username: username },
      },
    });
    if (!res.error) notify({ type: 'success', message: 'Elements dropped' });
  }, [notify, projectSlug, username]);
  return dropGeneratedElements;
}

/**
 * Get model file
 */
export function useGetModelFile(projectSlug: string | null | undefined) {
  const { notify } = useNotifications();

  const getModelFile = useCallback(
    async (model: string | null) => {
      const fileStream = streamSaver.createWriteStream(model + 'tar.gz');
      if (model && projectSlug) {
        const res = await api.GET('/export/bert', {
          params: {
            query: {
              project_slug: projectSlug,
              name: model,
            },
          },
          parseAs: 'stream',
        });

        const readableStream = res.data;
        if (!readableStream) {
          notify({ type: 'error', message: 'Error when downloading the model' });
          return null;
        }
        // more optimized
        if (window.WritableStream && readableStream.pipeTo) {
          await readableStream.pipeTo(fileStream);
          notify({ type: 'success', message: 'Model downloaded' });
        } else {
          notify({ type: 'error', message: 'Error when downloading the model' });
        }
      }
      return true;
    },
    [projectSlug, notify],
  );

  return { getModelFile };
}

/**
 * Get raw data file
 */
export function useGetRawDataFile(projectSlug: string | null | undefined) {
  const { notify } = useNotifications();

  const getRawDataFile = useCallback(async () => {
    if (projectSlug) {
      const fileStream = streamSaver.createWriteStream(projectSlug + '_dataset.parquet');
      const res = await api.GET('/export/raw', {
        params: {
          query: {
            project_slug: projectSlug,
          },
        },
        parseAs: 'stream',
      });

      const readableStream = res.data;
      if (!readableStream) {
        notify({ type: 'error', message: 'Error when downloading the model' });
        return null;
      }
      // more optimized
      if (window.WritableStream && readableStream.pipeTo) {
        await readableStream.pipeTo(fileStream);
        notify({ type: 'success', message: 'Model downloaded' });
      } else {
        notify({ type: 'error', message: 'Error when downloading the model' });
      }
    }
    return true;
  }, [projectSlug, notify]);

  return { getRawDataFile };
}

/**
 * Get dataset file static url
 */
export function useGetStaticUrls(projectSlug: string | null, model: string | null | undefined) {
  const [fetchTrigger, setFetchTrigger] = useState<boolean>(false);

  const getStaticUrls = useAsyncMemo(async () => {
    if (projectSlug) {
      const res = await api.GET('/export/static', {
        params: {
          query: {
            project_slug: projectSlug,
            model: model || null,
          },
        },
      });

      if (!res.error) {
        return res.data;
      }
      return null;
    }
    return null;
  }, [projectSlug, fetchTrigger]);

  const reFetch = useCallback(() => setFetchTrigger((f) => !f), []);
  return { staticUrls: getAsyncMemoData(getStaticUrls), reFetchUrl: reFetch };
}

/**
 * Get table of elements
 */
interface PageInfo {
  pageIndex: number;
  pageSize: number;
}
export function useTableElements(
  project_slug?: string,
  scheme?: string,
  initialPage?: number | null,
  initialPageSize?: number | null,
  search?: string | null,
  sample?: string,
  dataset?: string,
) {
  const [pageInfo, setPageInfo] = useState<PageInfo>({
    pageIndex: initialPage || 1,
    pageSize: initialPageSize || 10,
  });
  const [total, setTotal] = useState<number>(20);

  const getTableElements = useAsyncMemo(async () => {
    // if no project or scheme, return null
    if (scheme && project_slug) {
      const res = await api.POST('/elements/table', {
        params: {
          query: {
            project_slug: project_slug,
          },
        },
        body: {
          scheme: scheme,
          min: (pageInfo.pageIndex - 1) * pageInfo.pageSize,
          max: Math.min(pageInfo.pageIndex * pageInfo.pageSize, total),
          contains: search,
          mode: sample ? sample : 'all',
          dataset: dataset ? dataset : 'train',
        },
      });
      if (!res.error) {
        setTotal(res.data.total);
        return res.data.items;
      }
    }
    return null;
  }, [scheme, pageInfo, search, sample]);

  return { table: getAsyncMemoData(getTableElements), total, getPage: setPageInfo };
}

/**
 * Post update projection
 */
export function useUpdateProjection(
  projectSlug: string | null | undefined,
  scheme: string | null | undefined,
) {
  const { notify } = useNotifications();

  const updateProjection = useCallback(
    async (formData: ProjectionParametersModel) => {
      if (projectSlug && formData.features && scheme && formData.parameters) {
        const res = await api.POST('/elements/projection/compute', {
          params: {
            query: {
              project_slug: projectSlug,
            },
          },
          body: {
            method: formData.method,
            features: formData.features,
            parameters: formData.parameters,
          },
        });
        if (!res.error) notify({ type: 'warning', message: 'Vizualisation is being computed' });
      }
      return true;
    },
    [projectSlug, scheme, notify],
  );

  return { updateProjection };
}

/**
 * Get projection data
 */
export function useGetProjectionData(
  project_slug: string | undefined | null,
  scheme: string | undefined | null,
) {
  const [fetchTrigger, setFetchTrigger] = useState<boolean>(false);

  const getProjectionData = useAsyncMemo(async () => {
    if (scheme && project_slug) {
      const res = await api.GET('/elements/projection', {
        params: { query: { project_slug: project_slug, scheme: scheme } },
      });
      if (!res.error) {
        if ('data' in res) return res.data;
        else return null;
      }
    }
    return null;
  }, [fetchTrigger, scheme]);

  const reFetch = useCallback(() => setFetchTrigger((f) => !f), []);

  return { projectionData: getAsyncMemoData(getProjectionData), reFetchProjectionData: reFetch };
}

/** get version number */
export function useGetVersion() {
  const getVersion = useAsyncMemo(async () => {
    const res = await api.GET('/version', {});
    if (!res.error) return res.data;
    return null;
  }, []);
  return { version: getAsyncMemoData(getVersion) };
}

/**
 * Get server situation for a project
 */
export function useGetServer(projectState: ProjectStateModel | null) {
  const [fetchTrigger, setFetchTrigger] = useState<boolean>(false);

  const getServerState = useAsyncMemo(async () => {
    const res = await api.GET('/server', {});
    if (!res.error) {
      if ('data' in res) return res.data;
      else return null;
    }
    return null;
  }, [fetchTrigger, projectState]);

  const reFetch = useCallback(() => setFetchTrigger((f) => !f), []);

  const data = getAsyncMemoData(getServerState);

  return {
    version: data?.version,
    queueState: data?.queue,
    activeProjects: data?.active_projects,
    gpu: data?.gpu['gpu_available'] ? data?.gpu : undefined,
    cpu: data?.cpu,
    memory: data?.memory,
    disk: data?.disk,
    mail_available: data?.mail_available,
    messages: data?.messages,
    reFetchQueueState: reFetch,
  };
}

/**
 * Get table of disagreements
 */
export function useTableDisagreement(project_slug?: string, scheme?: string) {
  const [fetchTrigger, setFetchTrigger] = useState<boolean>(false);

  const getTable = useAsyncMemo(async () => {
    if (scheme && project_slug) {
      const res = await api.GET('/annotation/reconciliate', {
        params: {
          query: {
            project_slug: project_slug,
            scheme: scheme,
          },
        },
      });
      if (!res.error && res.data) {
        return res.data;
      }
    }
    return null;
  }, [project_slug, scheme, fetchTrigger]);
  const reFetch = useCallback(() => setFetchTrigger((f) => !f), []);
  const data = getAsyncMemoData(getTable);
  return {
    tableDisagreement: data ? data.table : null,
    users: data ? data.users : null,
    reFetchTable: reFetch,
  };
}

/**
 * Reconciliate annotations
 */
export function useReconciliate(projectSlug: string, scheme: string | null) {
  const { notify } = useNotifications();

  const postReconciliate = useCallback(
    async (element_id: string, label: string, users: string[]) => {
      if (scheme && projectSlug) {
        const res = await api.POST('/annotation/reconciliate', {
          params: {
            query: {
              project_slug: projectSlug,
              users: users,
              scheme: scheme,
              element_id: element_id,
              label: label,
            },
          },
        });
        if (!res.error) notify({ type: 'success', message: 'Reconciliation done' });

        return true;
      }
      return null;
    },
    [projectSlug, scheme, notify],
  );

  return { postReconciliate };
}

/**
 * Launch test
 */
export function useEvalModel(
  projectSlug: string | null,
  scheme: string | null,
  model: string | null,
) {
  const { notify } = useNotifications();

  const evalModel = useCallback(
    async (dataset: string) => {
      if (scheme && projectSlug && model) {
        const res = await api.POST('/models/bert/predict', {
          params: {
            query: {
              project_slug: projectSlug,
              scheme: scheme,
              model_name: model,
              dataset: dataset,
            },
          },
        });
        if (!res.error) notify({ type: 'warning', message: 'Starting evaluation' });

        return true;
      }
      return null;
    },
    [projectSlug, scheme, notify, model],
  );

  return { evalModel };
}

export function useGetGenModels() {
  const { notify } = useNotifications();
  const models = useCallback(async () => {
    const res = await api.GET('/generate/models/available');
    if (res.error) {
      notify({ type: 'error', message: 'Could not fetch available models' });
      return [];
    } else return res.data;
  }, [notify]);
  return { models };
}

export async function getProjectGenModels(
  project: string,
): Promise<Array<GenModel & { api: string }>> {
  const res = await api.GET(`/generate/models`, {
    params: {
      query: { project_slug: project },
    },
  });
  if (res.error) {
    console.error(res.error);
    return [];
  } else
    return res.data.map((model) => ({
      ...model,
      // Transform null to undefined
      endpoint: model.endpoint || undefined,
      credentials: model.credentials || undefined,
    }));
}

export async function createGenModel(
  project: string,
  model: Omit<GenModel & { api: SupportedAPI }, 'id'>,
): Promise<number> {
  const res = await api.POST(`/generate/models`, {
    params: { query: { project_slug: project } },
    body: model,
  });
  if (res.error) throw new Error(res.error.detail?.join() || 'Unable to create model');
  else return res.data;
}

export async function deleteGenModel(project: string, modelId: number) {
  const res = await api.DELETE(`/generate/models/{model_id}`, {
    params: { path: { model_id: modelId }, query: { project_slug: project } },
  });
  if (res.error) console.error(res.error);
}

/**
 * Post generate data
 */
export function useGenerate(
  projectSlug: string | null,
  currentScheme: string | null,
  modelId: number | null,
  n_batch: number | null,
  prompt: string | null,
  mode: string | null,
  token?: string,
) {
  const { notify } = useNotifications();
  const generate = useCallback(async () => {
    if (projectSlug && modelId && prompt && n_batch && currentScheme && mode) {
      const res = await api.POST('/generate/start', {
        params: {
          query: {
            project_slug: projectSlug,
          },
        },
        body: {
          model_id: modelId,
          prompt: prompt,
          n_batch: n_batch,
          token: token,
          scheme: currentScheme,
          mode: mode,
        },
      });
      if (!res.error) notify({ type: 'warning', message: 'Starting generation' });
      return true;
    }
    return null;
  }, [projectSlug, modelId, prompt, n_batch, currentScheme, mode, token, notify]);

  return { generate };
}

/**
 * Stop generation process for the user
 */
export function useStopGenerate(projectSlug: string | null) {
  const { notify } = useNotifications();
  const stopGenerate = useCallback(async () => {
    if (projectSlug) {
      const res = await api.POST('/generate/stop', {
        params: {
          query: {
            project_slug: projectSlug,
          },
        },
      });
      if (!res.error) notify({ type: 'success', message: 'Generation stopped' });
      return true;
    }
    return null;
  }, [projectSlug, notify]);

  return { stopGenerate };
}

/**
 * Get generated elements
 */
export function useGeneratedElements(
  project_slug: string | null,
  n_elements: number,
  filters: string[],
  isGenerating: boolean, // state for the user for refertching
) {
  const [fetchTrigger, setFetchTrigger] = useState<boolean>(false);

  const getGeneratedElements = useAsyncMemo(async () => {
    if (n_elements && project_slug) {
      const res = await api.POST('/generate/elements', {
        params: {
          query: {
            project_slug: project_slug,
          },
        },
        body: {
          n_elements: n_elements,
          filters: filters,
        },
      });
      if (!res.error && res.data && 'items' in res.data) {
        return res.data.items;
      }
    }
    return null;
  }, [project_slug, n_elements, isGenerating, fetchTrigger, filters]);

  const reFetch = useCallback(() => setFetchTrigger((f) => !f), []);

  return { generated: getAsyncMemoData(getGeneratedElements), reFetchGenerated: reFetch };
}

/**
 * Get logs
 */
export function useGetLogs(project_slug: string | null, limit: number) {
  const getLogs = useAsyncMemo(async () => {
    if (limit && project_slug) {
      const res = await api.GET('/logs', {
        params: {
          query: {
            project_slug: project_slug,
            limit: limit,
          },
        },
      });
      if (!res.error && res.data) {
        return res.data.items;
      }
    }
    return null;
  }, [project_slug, limit]);
  return { logs: getAsyncMemoData(getLogs) };
}

/**
 * Change password
 */
export function useChangePassword() {
  const { notify } = useNotifications();
  const changePassword = useCallback(
    async (pwdold: string, pwd1: string, pwd2: string) => {
      const res = await api.POST('/users/changepwd', {
        body: {
          pwdold: pwdold,
          pwd1: pwd1,
          pwd2: pwd2,
        },
      });
      if (!res.error) notify({ type: 'success', message: 'Password changed' });
      return true;
    },
    [notify],
  );

  return { changePassword };
}

export function useGetActiveUsers() {
  const [fetchTrigger, setFetchTrigger] = useState<boolean>(false);

  const getActiveUsers = useAsyncMemo(async () => {
    const res = await api.GET('/users/recent', {});
    return res.data;
  }, [fetchTrigger]);

  const reFetch = useCallback(() => setFetchTrigger((f) => !f), []);

  return { users: getAsyncMemoData(getActiveUsers), reFetchStatistics: reFetch };
}

/**
 * Get scheme codebook
 * @param project_slug - The slug of the project
 * @param scheme - The name of the scheme
 */
export function useGetSchemeCodebook(project_slug: string | null, scheme: string | null) {
  const [fetchTrigger, setFetchTrigger] = useState<boolean>(false);

  const getCodebook = useAsyncMemo(async () => {
    if (project_slug && scheme) {
      const res = await api.GET('/schemes/codebook', {
        params: {
          query: {
            project_slug: project_slug,
            scheme: scheme,
          },
        },
      });
      return res.data;
    }
    return null;
  }, [scheme, fetchTrigger]);

  const reFetch = useCallback(() => setFetchTrigger((f) => !f), []);

  const data = getAsyncMemoData(getCodebook);

  return {
    codebook: data ? data.content : '',
    time: data ? data.time : null,
    reFetchCodebook: reFetch,
  };
}

export function usePostSchemeCodebook(project_slug: string | null, scheme: string | null) {
  const { notify } = useNotifications();
  const postCodebook = useCallback(
    async (codebook: string, lastmodified: string) => {
      if (project_slug && scheme) {
        const res = await api.POST('/schemes/codebook', {
          params: {
            query: {
              project_slug: project_slug,
            },
          },
          body: {
            scheme: scheme,
            content: codebook,
            time: lastmodified,
          },
        });
        if (!res.error) notify({ type: 'success', message: 'Codebook updated' });
        return true;
      }
      return null;
    },
    [project_slug, scheme, notify],
  );

  return { postCodebook };
}

/**
 * Get compare 2 schemes
 */
export function useGetCompareSchemes(project_slug: string, schemeA: string, schemeB: string) {
  const [fetchTrigger, setFetchTrigger] = useState<boolean>(false);

  const getCompareSchemes = useAsyncMemo(async () => {
    if (project_slug && schemeA && schemeB) {
      const res = await api.GET('/schemes/compare', {
        params: {
          query: {
            project_slug: project_slug,
            schemeA: schemeA,
            schemeB: schemeB,
          },
        },
      });
      return res.data;
    }
    return null;
  }, [schemeA, schemeB, project_slug, fetchTrigger]);

  const reFetch = useCallback(() => setFetchTrigger((f) => !f), []);

  const data = getAsyncMemoData(getCompareSchemes);

  return {
    compare: data,
    reFetchCompare: reFetch,
  };
}

/**
 * Stop process generation by id
 */
export function useStopProcess() {
  const { notify } = useNotifications();
  const stopProcess = useCallback(
    async (uniqueId: string) => {
      const res = await api.POST('/stop', {
        params: {
          query: {
            unique_id: uniqueId,
          },
        },
      });
      if (!res.error) notify({ type: 'success', message: 'Process stopped' });
      return true;
    },
    [notify],
  );

  return { stopProcess };
}

/**
 * Stop all process for a user
 */
export function useStopProcesses() {
  const { notify } = useNotifications();
  const stopProcesses = useCallback(
    async (kind: string = 'all') => {
      const res = await api.POST('/stop', {
        params: {
          query: {
            unique_id: null,
            kind: kind,
          },
        },
      });
      if (!res.error) notify({ type: 'success', message: 'Processes ended' });
      return true;
    },
    [notify],
  );

  return { stopProcesses };
}

/**
 * Post annotation file
 */
export function usePostAnnotationsFile(projectSlug: string | null) {
  const { notify } = useNotifications();
  const postAnnotationsFile = useCallback(
    async (annotationsset: AnnotationsDataModel) => {
      if (!projectSlug) return;
      const res = await api.POST('/annotation/file', {
        params: {
          query: { project_slug: projectSlug },
        },
        body: annotationsset,
      });
      if (!res.error) notify({ type: 'success', message: 'Annotations set uploaded' });
      else
        throw new Error(
          res.error.detail ? res.error.detail?.map((d) => d.msg).join('; ') : res.error.toString(),
        );
    },
    [notify, projectSlug],
  );
  return postAnnotationsFile;
}

/**
 * Post update project
 */
export function useUpdateProject(projectSlug: string | null) {
  const { notify } = useNotifications();
  const updateProject = useCallback(
    async (formData: ProjectUpdateModel) => {
      if (projectSlug) {
        const res = await api.POST('/projects/update', {
          params: {
            query: { project_slug: projectSlug },
          },
          body: formData,
        });
        if (!res.error) notify({ type: 'success', message: 'Project updated' });
      }
    },
    [notify, projectSlug],
  );
  return updateProject;
}

/**
 * Get user statistics
 * @param username
 */
export function useGetUserStatistics(username: string | null) {
  const [fetchTrigger, setFetchTrigger] = useState<boolean>(false);

  const getUserStatistics = useAsyncMemo(async () => {
    if (username) {
      const res = await api.GET('/users/statistics', {
        params: {
          query: {
            username: username,
          },
        },
      });
      return res.data;
    }
    return null;
  }, [fetchTrigger]);

  const reFetch = useCallback(() => setFetchTrigger((f) => !f), []);

  return { userStatistics: getAsyncMemoData(getUserStatistics), reFetchStatistics: reFetch };
}

/**
 * Get prompts
 */
export function useGetPrompts(projectSlug: string | null) {
  const [fetchTrigger, setFetchTrigger] = useState<boolean>(false);

  const getPrompts = useAsyncMemo(async () => {
    if (projectSlug) {
      const res = await api.GET('/generate/prompts', {
        params: {
          query: {
            project_slug: projectSlug,
          },
        },
      });
      return res.data;
    }
    return null;
  }, [fetchTrigger]);

  const reFetch = useCallback(() => setFetchTrigger((f) => !f), []);

  return { prompts: getAsyncMemoData(getPrompts), reFetchPrompts: reFetch };
}

/**
 * Save prompts
 */
export function useSavePrompts(projectSlug: string | null) {
  const { notify } = useNotifications();
  const savePrompts = useCallback(
    async (prompt: string | null, name: string | null) => {
      if (projectSlug && prompt) {
        const res = await api.POST('/generate/prompts/add', {
          params: {
            query: { project_slug: projectSlug },
          },
          body: { text: prompt, name: name },
        });
        if (!res.error) notify({ type: 'success', message: 'Prompt saved' });
      }
    },
    [notify, projectSlug],
  );
  return savePrompts;
}

/**
 * Delete prompts
 */
export function useDeletePrompts(projectSlug: string | null) {
  const { notify } = useNotifications();
  const deletePrompts = useCallback(
    async (prompt_id: string | null) => {
      if (projectSlug && prompt_id) {
        const res = await api.POST('/generate/prompts/delete', {
          params: {
            query: { project_slug: projectSlug, prompt_id: prompt_id },
          },
        });
        if (!res.error) notify({ type: 'success', message: 'Prompt deleted' });
      }
    },
    [notify, projectSlug],
  );
  return deletePrompts;
}

/***** MANAGE Files ******/

/**
 * Get available files
 */
export function useGetFiles() {
  const [fetchTrigger, setFetchTrigger] = useState<boolean>(false);

  const getFiles = useAsyncMemo(async () => {
    const res = await api.GET('/files');

    return res.data;
  }, [fetchTrigger]);

  const reFetch = useCallback(() => setFetchTrigger((f) => !f), []);

  return { files: getAsyncMemoData(getFiles), reFetchFiles: reFetch };
}

/**
 * Delete a file
 */
export function useDeleteFile(reFetchFiles: () => void) {
  const { notify } = useNotifications();
  const deleteFile = useCallback(
    async (filename: string | null) => {
      if (filename) {
        const res = await api.POST('/files/delete', {
          params: {
            query: { filename: filename },
          },
        });
        if (!res.error) notify({ type: 'success', message: 'File deleted' });
        reFetchFiles();
      }
    },
    [notify, reFetchFiles],
  );
  return deleteFile;
}

/**
 * Test if project name is available
 */
export function useProjectNameAvailable() {
  const testProjectName = useCallback(async (project_name: string) => {
    const res = await api.GET('/projects/status', {
      params: {
        query: { project_name: project_name },
      },
    });
    if (res.data) return res.data === 'not existing' ? true : false;
    else return false;
  }, []);
  return testProjectName;
}

/**
 * Get project creation status as a function
 */
export async function getProjectStatus(projectSlug: string) {
  const res = await api.GET('/projects/status', {
    params: {
      query: {
        project_name: projectSlug,
      },
    },
  });

  return res.data;
}

/**
 * Add file
 */
export function useAddProjectFile() {
  const { notify } = useNotifications();
  const { authenticatedUser } = useAuth();

  // state to monitor progression
  const [progression, setProgression] = useState<{ loaded?: number; total?: number }>({});
  // state to allow user top cancel operation
  const [controller, setController] = useState<AbortController | undefined>(undefined);

  // main callback to upload to API
  const addProjectFile = useCallback(
    async (project_name: string, file: File) => {
      try {
        // create a new controller
        const controller = new AbortController();
        // update state
        setController(controller);
        // use axios instead of openapi fetch to follow progression
        const url = config.api.url.replace(/\/$/, '');
        await axios.postForm(
          `${url}/files/add/project`,
          { file },
          {
            // signal to abort
            signal: controller.signal,
            params: {
              project_name,
            },
            // add auth
            headers: getAuthHeaders(authenticatedUser)?.headers,
            // update progression state
            onUploadProgress: (progressEvent) => {
              const { loaded, total } = progressEvent;
              setProgression({ loaded, total });
            },
          },
        );
        notify({ type: 'success', message: 'File uploaded' });
      } catch (error) {
        notify({ type: 'error', message: `Upload failed: ${error}` });
      } finally {
        // reset internal state
        setProgression({});
        setController(undefined);
      }
    },
    [notify, authenticatedUser, setController],
  );

  return {
    addProjectFile,
    progression,
    cancel: controller,
  };
}

/**
 * Copy existing data
 */
export function useCopyExistingData() {
  const copyExistingData = useCallback(async (project_name: string, source_project: string) => {
    await api.POST('/files/copy/project', {
      params: {
        query: { project_name: project_name, source_project: source_project },
      },
    });
  }, []);
  return copyExistingData;
}

/**
 * Restart the queue
 */
export function useRestartQueue() {
  const { notify } = useNotifications();
  const restartQueue = useCallback(async () => {
    const res = await api.POST('/server/restart', {});
    if (!res.error) notify({ type: 'success', message: 'Queue restarted' });
    return true;
  }, [notify]);
  return { restartQueue };
}

/**
 * Launch a Bertopic
 */
export function useComputeBertopic(projectSlug: string | null) {
  const { notify } = useNotifications();
  const computeBertopic = useCallback(
    async (dataForm: ComputeBertopicModel) => {
      if (projectSlug && dataForm) {
        const res = await api.POST('/bertopic/compute', {
          params: {
            query: { project_slug: projectSlug },
          },
          body: dataForm,
        });
        if (!res.error) notify({ type: 'warning', message: 'Starting bertopic computing' });
        return res.data;
      }
      return null;
    },
    [projectSlug, notify],
  );

  return { computeBertopic };
}

/**
 * Delete a bertopic result
 */
export function useDeleteBertopic(projectSlug: string | null) {
  const { notify } = useNotifications();
  const deleteBertopic = useCallback(
    async (name: string | null) => {
      if (projectSlug && name) {
        const res = await api.POST('/bertopic/delete', {
          params: {
            query: { project_slug: projectSlug, name: name },
          },
        });
        if (!res.error) notify({ type: 'success', message: 'Bertopic deleted' });
      }
    },
    [notify, projectSlug],
  );
  return deleteBertopic;
}

/**
 * Get topics from a bertopic
 */

export function useGetBertopicTopics(projectSlug: string | null, name: string | null) {
  const [fetchTrigger, setFetchTrigger] = useState<boolean>(false);

  const getBertopicTopics = useAsyncMemo(async () => {
    if (projectSlug && name) {
      const res = await api.GET('/bertopic/topics', {
        params: {
          query: { project_slug: projectSlug, name: name },
        },
      });
      return res.data;
    }
    return null;
  }, [fetchTrigger]);

  const reFetch = useCallback(() => setFetchTrigger((f) => !f), []);

  const data = getAsyncMemoData(getBertopicTopics);

  return { topics: data?.topics, parameters: data?.parameters, reFetchTopics: reFetch };
}

/**
 * Get projection
 */

export function useGetBertopicProjection(projectSlug: string | null, name: string | null) {
  const [fetchTrigger, setFetchTrigger] = useState<boolean>(false);

  const getBertopicProjection = useAsyncMemo(async () => {
    if (projectSlug && name) {
      const res = await api.GET('/bertopic/projection', {
        params: {
          query: { project_slug: projectSlug, name: name },
        },
      });
      return res.data;
    }
    return null;
  }, [fetchTrigger]);

  const reFetch = useCallback(() => setFetchTrigger((f) => !f), []);

  const data = getAsyncMemoData(getBertopicProjection);

  return { projection: data, reFetchProjection: reFetch };
}

/**
 * Get bertopic topics
 */
export function useDownloadBertopicTopics(projectSlug: string | null) {
  const { notify } = useNotifications();
  const downloadBertopicTopics = useCallback(
    async (name: string) => {
      if (projectSlug) {
        const res = await api.GET('/export/bertopic/topics', {
          params: {
            query: {
              project_slug: projectSlug,
              name: name,
            },
          },
          parseAs: 'blob',
        });

        if (!res.error) {
          notify({ type: 'success', message: 'Exporting bertopic topics' });
          saveAs(res.data, `bertopic_topics_${projectSlug}_${name}`);
        }
        return true;
      }
      return null;
    },
    [projectSlug, notify],
  );

  return { downloadBertopicTopics };
}

/**
 * Get bertopic clusters
 */
export function useDownloadBertopicClusters(projectSlug: string | null) {
  const { notify } = useNotifications();
  const downloadBertopicClusters = useCallback(
    async (name: string) => {
      if (projectSlug) {
        const res = await api.GET('/export/bertopic/clusters', {
          params: {
            query: {
              project_slug: projectSlug,
              name: name,
            },
          },
          parseAs: 'blob',
        });

        if (!res.error) {
          notify({ type: 'success', message: 'Exporting bertopic clusters' });
          saveAs(res.data, `bertopic_clusters_${projectSlug}_${name}`);
        }
        return true;
      }
      return null;
    },
    [projectSlug, notify],
  );

  return { downloadBertopicClusters };
}

/**
 * Send reset mail
 */

export function useSendResetMail() {
  const { notify } = useNotifications();
  const sendResetMail = useCallback(
    async (mail: string) => {
      const res = await api.POST('/users/resetpwd', {
        params: {
          query: {
            mail: mail,
          },
        },
      });
      if (!res.error) notify({ type: 'success', message: 'An email has been sent to you' });
    },
    [notify],
  );

  return { sendResetMail };
}

/**
 * Send message
 */

export function useSendMessage() {
  const { notify } = useNotifications();
  const sendMessage = useCallback(
    async (content: string, kind: string) => {
      const res = await api.POST('/messages', {
        body: {
          content: content,
          kind: kind,
        },
      });
      if (!res.error) notify({ type: 'success', message: 'Your message has been sent' });
    },
    [notify],
  );

  return { sendMessage };
}

/**
 * Get messages
 */

export function useGetMessages(kind: string, from_user: string | null) {
  const [fetchTrigger, setFetchTrigger] = useState<boolean>(false);

  const getMessages = useAsyncMemo(async () => {
    const res = await api.GET('/messages', {
      params: {
        query: { kind: kind, from_user: from_user },
      },
    });
    return res.data;
  }, [fetchTrigger]);

  const reFetch = useCallback(() => setFetchTrigger((f) => !f), []);

  return { messages: getAsyncMemoData(getMessages), reFetchMessages: reFetch };
}

export function useDeleteMessage() {
  const { notify } = useNotifications();
  const deleteMessage = useCallback(
    async (message_id: number) => {
      const res = await api.POST(`/messages/delete`, {
        params: {
          query: { message_id: message_id },
        },
      });
      if (!res.error) notify({ type: 'success', message: 'Your message has been deleted' });
    },
    [notify],
  );

  return { deleteMessage };
}

export function useGetAvailableDatasets() {
  const [fetchTrigger, setFetchTrigger] = useState<boolean>(false);

  const getDatasets = useAsyncMemo(async () => {
    const res = await api.GET('/datasets');
    if (res.data && !res.error) return res.data;
    else {
      return null;
    }
  }, [fetchTrigger]);
  const reFetch = useCallback(() => setFetchTrigger((f) => !f), []);

  return { datasets: getAsyncMemoData(getDatasets) || null, reFetchProjects: reFetch };
}
